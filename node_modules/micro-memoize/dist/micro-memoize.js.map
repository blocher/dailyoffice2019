{"version":3,"file":"micro-memoize.js","sources":["../src/utils.ts","../src/Cache.ts","../src/index.ts"],"sourcesContent":["import { Dictionary, MicroMemoize } from './types';\n\n/**\n * @constant DEFAULT_OPTIONS_KEYS the default options keys\n */\nconst DEFAULT_OPTIONS_KEYS: Dictionary<true> = {\n  isEqual: true,\n  isMatchingKey: true,\n  isPromise: true,\n  maxSize: true,\n  onCacheAdd: true,\n  onCacheChange: true,\n  onCacheHit: true,\n  transformKey: true,\n};\n\n/**\n * @function slice\n *\n * @description\n * slice.call() pre-bound\n */\nexport const { slice } = Array.prototype;\n\n/**\n * @function cloneArray\n *\n * @description\n * clone the array-like object and return the new array\n *\n * @param arrayLike the array-like object to clone\n * @returns the clone as an array\n */\nexport function cloneArray(arrayLike: any[] | IArguments) {\n  const { length } = arrayLike;\n\n  if (!length) {\n    return [];\n  }\n\n  if (length === 1) {\n    return [arrayLike[0]];\n  }\n\n  if (length === 2) {\n    return [arrayLike[0], arrayLike[1]];\n  }\n\n  if (length === 3) {\n    return [arrayLike[0], arrayLike[1], arrayLike[2]];\n  }\n\n  return slice.call(arrayLike, 0);\n}\n\n/**\n * @function getCustomOptions\n *\n * @description\n * get the custom options on the object passed\n *\n * @param options the memoization options passed\n * @returns the custom options passed\n */\nexport function getCustomOptions(options: MicroMemoize.Options) {\n  const customOptions: MicroMemoize.Options = {};\n\n  /* eslint-disable no-restricted-syntax */\n\n  for (const key in options) {\n    if (!DEFAULT_OPTIONS_KEYS[key]) {\n      customOptions[key] = options[key];\n    }\n  }\n\n  /* eslint-enable */\n\n  return customOptions;\n}\n\n/**\n * @function isMemoized\n *\n * @description\n * is the function passed already memoized\n *\n * @param fn the function to test\n * @returns is the function already memoized\n */\nexport function isMemoized(fn: any): fn is MicroMemoize.Memoized<Function> {\n  return (\n    typeof fn === 'function' &&\n    (fn as MicroMemoize.Memoized<Function>).isMemoized\n  );\n}\n\n/**\n * @function isSameValueZero\n *\n * @description\n * are the objects equal based on SameValueZero equality\n *\n * @param object1 the first object to compare\n * @param object2 the second object to compare\n * @returns are the two objects equal\n */\nexport function isSameValueZero(object1: any, object2: any) {\n  // eslint-disable-next-line no-self-compare\n  return object1 === object2 || (object1 !== object1 && object2 !== object2);\n}\n\n/**\n * @function mergeOptions\n *\n * @description\n * merge the options into the target\n *\n * @param existingOptions the options provided\n * @param newOptions the options to include\n * @returns the merged options\n */\nexport function mergeOptions(\n  existingOptions: MicroMemoize.NormalizedOptions,\n  newOptions: MicroMemoize.Options,\n): Readonly<MicroMemoize.NormalizedOptions> {\n  // @ts-ignore\n  const target: MicroMemoize.NormalizedOptions = {};\n\n  /* eslint-disable no-restricted-syntax */\n\n  for (const key in existingOptions) {\n    target[key] = existingOptions[key];\n  }\n\n  for (const key in newOptions) {\n    target[key] = newOptions[key];\n  }\n\n  /* eslint-enable */\n\n  return target;\n}\n","import { MicroMemoize } from './types';\n\n// utils\nimport { cloneArray } from './utils';\n\nexport class Cache {\n  readonly canTransformKey: boolean;\n\n  readonly getKeyIndex: MicroMemoize.KeyIndexGetter;\n\n  readonly options: MicroMemoize.NormalizedOptions;\n\n  readonly shouldCloneArguments: boolean;\n\n  readonly shouldUpdateOnAdd: boolean;\n\n  readonly shouldUpdateOnChange: boolean;\n\n  readonly shouldUpdateOnHit: boolean;\n\n  keys: MicroMemoize.Key[];\n\n  values: MicroMemoize.Value[];\n\n  constructor(options: MicroMemoize.NormalizedOptions) {\n    this.keys = [];\n    this.values = [];\n    this.options = options;\n\n    const isMatchingKeyFunction = typeof options.isMatchingKey === 'function';\n\n    if (isMatchingKeyFunction) {\n      this.getKeyIndex = this._getKeyIndexFromMatchingKey;\n    } else if (options.maxSize > 1) {\n      this.getKeyIndex = this._getKeyIndexForMany;\n    } else {\n      this.getKeyIndex = this._getKeyIndexForSingle;\n    }\n\n    this.canTransformKey = typeof options.transformKey === 'function';\n    this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;\n\n    this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';\n    this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';\n    this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';\n  }\n\n  get size() {\n    return this.keys.length;\n  }\n\n  get snapshot() {\n    return {\n      keys: cloneArray(this.keys),\n      size: this.size,\n      values: cloneArray(this.values),\n    };\n  }\n\n  /**\n   * @function _getKeyIndexFromMatchingKey\n   *\n   * @description\n   * gets the matching key index when a custom key matcher is used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexFromMatchingKey(keyToMatch: MicroMemoize.RawKey) {\n    const { isMatchingKey, maxSize } = this.options as {\n      isMatchingKey: MicroMemoize.MatchingKeyComparator;\n      maxSize: number;\n    };\n\n    const { keys } = this;\n    const keysLength = keys.length;\n\n    if (!keysLength) {\n      return -1;\n    }\n\n    if (isMatchingKey(keys[0], keyToMatch)) {\n      return 0;\n    }\n\n    if (maxSize > 1) {\n      for (let index = 1; index < keysLength; index++) {\n        if (isMatchingKey(keys[index], keyToMatch)) {\n          return index;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * @function _getKeyIndexForMany\n   *\n   * @description\n   * gets the matching key index when multiple keys are used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexForMany(keyToMatch: MicroMemoize.RawKey) {\n    const { isEqual } = this.options;\n\n    const { keys } = this;\n    const keysLength = keys.length;\n\n    if (!keysLength) {\n      return -1;\n    }\n\n    if (keysLength === 1) {\n      return this._getKeyIndexForSingle(keyToMatch);\n    }\n\n    const keyLength = keyToMatch.length;\n\n    let existingKey;\n    let argIndex;\n\n    if (keyLength > 1) {\n      for (let index = 0; index < keysLength; index++) {\n        existingKey = keys[index];\n\n        if (existingKey.length === keyLength) {\n          argIndex = 0;\n\n          for (; argIndex < keyLength; argIndex++) {\n            if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {\n              break;\n            }\n          }\n\n          if (argIndex === keyLength) {\n            return index;\n          }\n        }\n      }\n    } else {\n      for (let index = 0; index < keysLength; index++) {\n        existingKey = keys[index];\n\n        if (\n          existingKey.length === keyLength &&\n          isEqual(existingKey[0], keyToMatch[0])\n        ) {\n          return index;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * @function _getKeyIndexForSingle\n   *\n   * @description\n   * gets the matching key index when a single key is used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexForSingle(keyToMatch: MicroMemoize.RawKey) {\n    const { keys } = this;\n\n    if (!keys.length) {\n      return -1;\n    }\n\n    const existingKey = keys[0];\n    const { length } = existingKey;\n\n    if (keyToMatch.length !== length) {\n      return -1;\n    }\n\n    const { isEqual } = this.options;\n\n    if (length > 1) {\n      for (let index = 0; index < length; index++) {\n        if (!isEqual(existingKey[index], keyToMatch[index])) {\n          return -1;\n        }\n      }\n\n      return 0;\n    }\n\n    return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;\n  }\n\n  /**\n   * @function orderByLru\n   *\n   * @description\n   * order the array based on a Least-Recently-Used basis\n   *\n   * @param key the new key to move to the front\n   * @param value the new value to move to the front\n   * @param startingIndex the index of the item to move to the front\n   */\n  orderByLru(\n    key: MicroMemoize.Key,\n    value: MicroMemoize.Value,\n    startingIndex: number,\n  ) {\n    const { keys } = this;\n    const { values } = this;\n\n    const currentLength = keys.length;\n\n    let index = startingIndex;\n\n    while (index--) {\n      keys[index + 1] = keys[index];\n      values[index + 1] = values[index];\n    }\n\n    keys[0] = key;\n    values[0] = value;\n\n    const { maxSize } = this.options;\n\n    if (currentLength === maxSize && startingIndex === currentLength) {\n      keys.pop();\n      values.pop();\n    } else if (startingIndex >= maxSize) {\n      // eslint-disable-next-line no-multi-assign\n      keys.length = values.length = maxSize;\n    }\n  }\n\n  /**\n   * @function updateAsyncCache\n   *\n   * @description\n   * update the promise method to auto-remove from cache if rejected, and\n   * if resolved then fire cache hit / changed\n   *\n   * @param memoized the memoized function\n   */\n  updateAsyncCache(memoized: MicroMemoize.Memoized<Function>) {\n    const { onCacheChange, onCacheHit } = this.options as {\n      onCacheChange: MicroMemoize.CacheModifiedHandler;\n      onCacheHit: MicroMemoize.CacheModifiedHandler;\n    };\n\n    const [firstKey] = this.keys;\n    const [firstValue] = this.values;\n\n    this.values[0] = firstValue.then(\n      (value: any) => {\n        if (this.shouldUpdateOnHit) {\n          onCacheHit(this, this.options, memoized);\n        }\n\n        if (this.shouldUpdateOnChange) {\n          onCacheChange(this, this.options, memoized);\n        }\n\n        return value;\n      },\n      (error: Error) => {\n        const keyIndex = this.getKeyIndex(firstKey);\n\n        if (keyIndex !== -1) {\n          this.keys.splice(keyIndex, 1);\n          this.values.splice(keyIndex, 1);\n        }\n\n        throw error;\n      },\n    );\n  }\n}\n","// cache\nimport { Cache } from './Cache';\n\n// types\nimport { MicroMemoize } from './types';\n\n// utils\nimport {\n  cloneArray,\n  getCustomOptions,\n  isMemoized,\n  isSameValueZero,\n  mergeOptions,\n} from './utils';\n\nfunction createMemoizedFunction<Fn extends Function>(\n  fn: Fn | MicroMemoize.Memoized<Fn>,\n  options: MicroMemoize.Options = {},\n): MicroMemoize.Memoized<Fn> {\n  if (isMemoized(fn)) {\n    return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('You must pass a function to `memoize`.');\n  }\n\n  const {\n    isEqual = isSameValueZero,\n    isMatchingKey,\n    isPromise = false,\n    maxSize = 1,\n    onCacheAdd,\n    onCacheChange,\n    onCacheHit,\n    transformKey,\n  } = options;\n\n  const normalizedOptions = mergeOptions(\n    {\n      isEqual,\n      isMatchingKey,\n      isPromise,\n      maxSize,\n      onCacheAdd,\n      onCacheChange,\n      onCacheHit,\n      transformKey,\n    },\n    getCustomOptions(options),\n  );\n\n  const cache = new Cache(normalizedOptions);\n\n  const {\n    keys,\n    values,\n    canTransformKey,\n    shouldCloneArguments,\n    shouldUpdateOnAdd,\n    shouldUpdateOnChange,\n    shouldUpdateOnHit,\n  } = cache;\n\n  // @ts-ignore\n  const memoized: Memoized<Fn> = function memoized(this) {\n    // @ts-ignore\n    let key: MicroMemoize.Key = shouldCloneArguments\n      ? cloneArray(arguments)\n      : arguments;\n\n    if (canTransformKey) {\n      key = (transformKey as MicroMemoize.KeyTransformer)(key);\n    }\n\n    const keyIndex = keys.length ? cache.getKeyIndex(key) : -1;\n\n    if (keyIndex !== -1) {\n      if (shouldUpdateOnHit) {\n        (onCacheHit as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n\n      if (keyIndex) {\n        cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);\n\n        if (shouldUpdateOnChange) {\n          (onCacheChange as MicroMemoize.CacheModifiedHandler)(\n            cache,\n            normalizedOptions,\n            memoized,\n          );\n        }\n      }\n    } else {\n      const newValue = fn.apply(this, arguments);\n      const newKey = shouldCloneArguments\n        ? (key as any[])\n        : cloneArray(arguments);\n\n      cache.orderByLru(newKey, newValue, keys.length);\n\n      if (isPromise) {\n        cache.updateAsyncCache(memoized);\n      }\n\n      if (shouldUpdateOnAdd) {\n        (onCacheAdd as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n\n      if (shouldUpdateOnChange) {\n        (onCacheChange as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n    }\n\n    return values[0];\n  };\n\n  memoized.cache = cache;\n  memoized.fn = fn;\n  memoized.isMemoized = true as const;\n  memoized.options = normalizedOptions;\n\n  return memoized;\n}\n\nexport default createMemoizedFunction;\n"],"names":[],"mappings":"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"}