{"version":3,"sources":["../../../src/cache/offline.js"],"names":["handleOfflineError","error","isOfflineError","cachedVersions","undefined","message","includes","OFFLINE_ERROR_MESSAGE"],"mappings":"wGAAA;;;;AAIO,KAAMA,CAAAA,kBAAkB,CAAG,eAAgBC,KAAhB,CAAuB;AACvD,GAAI,CAACC,cAAc,CAACD,KAAD,CAAnB,CAA4B;AAC1B,KAAMA,CAAAA,KAAN;AACD;;AAED,KAAME,CAAAA,cAAc,CAAG,KAAM,6BAAmB,KAAnB,CAA7B;;AAEA,GAAIA,cAAc,GAAKC,SAAvB,CAAkC;AAChC,KAAMH,CAAAA,KAAN;AACD;;AAED,MAAOE,CAAAA,cAAP;AACD,CAZM,C;;;;;AAiBP,KAAMD,CAAAA,cAAc,CAAG,SAAU,CAAEG,OAAF,CAAV,CAAuB;AAC5C,MAAOA,CAAAA,OAAO,CAACC,QAAR,CAAiBC,qBAAjB,CAAP;AACD,CAFD;;AAIA,KAAMA,CAAAA,qBAAqB,CAAG,aAA9B","sourcesContent":["import { readCachedVersions } from './read.js'\n\n// When offline, we try to reuse cached versions if any is available.\n// We do this even if `fetch` option is `true`.\nexport const handleOfflineError = async function (error) {\n  if (!isOfflineError(error)) {\n    throw error\n  }\n\n  const cachedVersions = await readCachedVersions(false)\n\n  if (cachedVersions === undefined) {\n    throw error\n  }\n\n  return cachedVersions\n}\n\n// On Windows, offline errors are the same as wrong `mirror` option errors.\n// Since we cannot distinguish them, we also use offline cache when `mirror`\n// option is invalid.\nconst isOfflineError = function ({ message }) {\n  return message.includes(OFFLINE_ERROR_MESSAGE)\n}\n\nconst OFFLINE_ERROR_MESSAGE = 'getaddrinfo'\n"],"file":"src/cache/offline.js"}