"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const base_1 = require("../../../base");
const bash_1 = require("../../../utils/bash");
const fish_1 = require("../../../utils/fish");
class CompletionGenerateAlias extends base_1.CompletionBase {
    async run() {
        const { args, flags } = this.parse(CompletionGenerateAlias);
        const shell = flags.shell;
        const { bin } = this.config;
        const alias = args.ALIAS;
        if (bin === alias) {
            return this.error(`ALIAS can not be ${bin}`, { exit: 1 });
        }
        let scriptContent = '';
        if (shell === 'bash') {
            scriptContent = bash_1.generateCompletionAliasScriptForBash({ bin, alias });
        }
        if (shell === 'fish') {
            scriptContent = fish_1.generateCompletionAliasScriptForFish({ bin, alias });
        }
        if (shell === 'zsh') {
            this.error(`not needed for ${shell}`, { exit: 1 });
        }
        this.log(scriptContent);
    }
}
exports.default = CompletionGenerateAlias;
CompletionGenerateAlias.description = [
    `Generates completion script for alias`,
    ``,
    `This needs the completion script for the main command to be present.`,
    ``,
    `Check the "completion:generate" command.`,
].join('\n');
CompletionGenerateAlias.args = [
    {
        name: 'ALIAS',
        required: true,
        description: 'name of the alias',
    },
];
CompletionGenerateAlias.flags = Object.assign(Object.assign({}, base_1.CompletionBase.flags), { shell: command_1.flags.string(Object.assign(Object.assign({}, base_1.CompletionBase.flags.shell), { options: (_a = base_1.CompletionBase.flags.shell.options) === null || _a === void 0 ? void 0 : _a.filter((shell) => shell !== 'zsh'), required: true })) });
