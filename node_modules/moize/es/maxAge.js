// types
// utils
import { createFindKeyIndex, findExpirationIndex } from './utils';
/**
 * @private
 *
 * @function clearExpiration
 *
 * @description
 * clear an active expiration and remove it from the list if applicable
 *
 * @param {Array<Expiration>} expirations the list of expirations
 * @param {any} key the key to clear
 * @param {boolean} [shouldRemove] should the expiration be removed from the list
 */

export var clearExpiration = function clearExpiration(expirations, key, shouldRemove) {
  var expirationIndex = findExpirationIndex(expirations, key);

  if (~expirationIndex) {
    clearTimeout(expirations[expirationIndex].timeoutId);

    if (shouldRemove) {
      expirations.splice(expirationIndex, 1);
    }
  }
};
/**
 * @private
 * 
 * @function createTimeout
 * 
 * @description
 * Create the timeout for the given expiration method. If the ability to `unref`
 * exists, then apply it to avoid process locks in NodeJS.
 * 
 * @param {function} expirationMethod the method to fire upon expiration
 * @param {number} maxAge the time to expire after
 * @returns {TimeoutID} the timeout ID
 */

export var createTimeout = function createTimeout(expirationMethod, maxAge) {
  var timeoutId = setTimeout(expirationMethod, maxAge); // $FlowIgnore check that `unref` is a property on `timeoutId`

  if (typeof timeoutId.unref === 'function') {
    timeoutId.unref();
  }

  return timeoutId;
};
export var createOnCacheAddSetExpiration = function createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) {
  var maxAge = options.maxAge,
      onCacheChange = options.onCacheChange,
      onExpire = options.onExpire;
  var findKeyIndex = createFindKeyIndex(isEqual, isMatchingKey);
  /**
   * @private
   *
   * @function onCacheAdd
   *
   * @description
   * when an item is added to the cache, add an expiration for it
   *
   * @modifies {expirations}
   *
   * @param {Cache} cache the cache of the memoized function
   * @param {Options} moizedOptions the options passed to the memoized function
   * @param {function} moized the memoized function
   * @returns {void}
   */

  return function onCacheAdd(cache, moizedOptions, moized) {
    var key = cache.keys[0];

    if (!~findExpirationIndex(expirations, key)) {
      var expirationMethod = function expirationMethod() {
        var keyIndex = findKeyIndex(cache.keys, key);
        var value = cache.values[keyIndex];

        if (~keyIndex) {
          cache.keys.splice(keyIndex, 1);
          cache.values.splice(keyIndex, 1);

          if (typeof onCacheChange === 'function') {
            onCacheChange(cache, moizedOptions, moized);
          }
        }

        clearExpiration(expirations, key, true);

        if (typeof onExpire === 'function' && onExpire(key) === false) {
          cache.keys.unshift(key);
          cache.values.unshift(value);
          createOnCacheAddSetExpiration(expirations, options, isEqual)(cache, moizedOptions, moized);

          if (typeof onCacheChange === 'function') {
            onCacheChange(cache, moizedOptions, moized);
          }
        }
      };

      expirations.push({
        expirationMethod: expirationMethod,
        key: key,
        // $FlowIgnore maxAge is an number
        timeoutId: createTimeout(expirationMethod, maxAge)
      });
    }
  };
};
export var createOnCacheHitResetExpiration = function createOnCacheHitResetExpiration(expirations, options) {
  var maxAge = options.maxAge;
  /**
   * @private
   *
   * @function onCacheHit
   *
   * @description
   * when a cache item is hit, reset the expiration
   *
   * @modifies {expirations}
   *
   * @param {Cache} cache the cache of the memoized function
   * @returns {void}
   */

  return function onCacheHit(cache) {
    var key = cache.keys[0];
    var expirationIndex = findExpirationIndex(expirations, key);

    if (~expirationIndex) {
      clearExpiration(expirations, key, false); // $FlowIgnore maxAge is a number

      expirations[expirationIndex].timeoutId = createTimeout(expirations[expirationIndex].expirationMethod, maxAge);
    }
  };
};
/**
 * @private
 *
 * @function getMaxAgeOptions
 *
 * @description
 * get the micro-memoize options specific to the maxAge option
 *
 * @param {Array<Expiration>} expirations the expirations for the memoized function
 * @param {Options} options the options passed to the moizer
 * @param {function} isEqual the function to test equality of the key on a per-argument basis
 * @param {function} isMatchingKey the function to test equality of the whole key
 * @returns {Object} the object of options based on the entries passed
 */

export var getMaxAgeOptions = function getMaxAgeOptions(expirations, options, isEqual, isMatchingKey) {
  var maxAge = options.maxAge,
      updateExpire = options.updateExpire;
  var onCacheAdd = typeof maxAge === 'number' && isFinite(maxAge) ? createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) : undefined;
  return {
    onCacheAdd: onCacheAdd,
    onCacheHit: onCacheAdd && updateExpire ? createOnCacheHitResetExpiration(expirations, options) : undefined
  };
};